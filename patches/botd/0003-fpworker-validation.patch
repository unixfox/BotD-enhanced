From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Emilien <4016501+unixfox@users.noreply.github.com>
Date: Sun, 7 Sep 2025 21:59:56 +0200
Subject: [PATCH 3/6] fpworker validation

---
 src/detectors/fpworker_validation.ts    |  24 +++
 src/sources/fpworker_validation.test.ts |  33 ++++
 src/sources/fpworker_validation.ts      | 246 ++++++++++++++++++++++++
 3 files changed, 303 insertions(+)
 create mode 100644 src/detectors/fpworker_validation.ts
 create mode 100644 src/sources/fpworker_validation.test.ts
 create mode 100644 src/sources/fpworker_validation.ts

diff --git a/src/detectors/fpworker_validation.ts b/src/detectors/fpworker_validation.ts
new file mode 100644
index 0000000..2330f65
--- /dev/null
+++ b/src/detectors/fpworker_validation.ts
@@ -0,0 +1,24 @@
+import { BotKind, ComponentDict, DetectorResponse, State } from '../types'
+
+export function detectFpWorkerValidation({ fpworkerValidation }: ComponentDict): DetectorResponse {
+  if (fpworkerValidation.state !== State.Success || !fpworkerValidation.value) {
+    return
+  }
+
+  const data = fpworkerValidation.value
+
+  // If we have both window and service worker data, compare them
+  if (data.serviceWorker) {
+    const windowScope = data.windowScope
+    const serviceWorker = data.serviceWorker
+
+    // If any fingerprint property differs between window and service worker, it's a bot
+    // This follows your requirement: "if there is a diff it's an unknown bot"
+    if (windowScope.engine !== serviceWorker.engine ||
+        windowScope.timeZone !== serviceWorker.timeZone ||
+        windowScope.userAgent !== serviceWorker.userAgent ||
+        windowScope.language !== serviceWorker.language) {
+      return BotKind.Unknown
+    }
+  }
+}
diff --git a/src/sources/fpworker_validation.test.ts b/src/sources/fpworker_validation.test.ts
new file mode 100644
index 0000000..0e805ef
--- /dev/null
+++ b/src/sources/fpworker_validation.test.ts
@@ -0,0 +1,33 @@
+import getFpWorkerValidation from './fpworker_validation'
+
+describe('Sources', () => {
+  describe('fpworkerValidation', () => {
+    it('should return valid fpworker validation data', async () => {
+      const result = await getFpWorkerValidation()
+      
+      expect(result).toBeDefined()
+      expect(typeof result.windowScope).toBe('object')
+      expect(typeof result.windowScope.timeZone).toBe('string')
+      expect(typeof result.windowScope.language).toBe('string')
+      expect(typeof result.windowScope.userAgent).toBe('string')
+      expect(typeof result.windowScope.engine).toBe('string')
+      expect(typeof result.isServiceWorkerSupported).toBe('boolean')
+      expect(typeof result.isSharedWorkerSupported).toBe('boolean')
+      expect(typeof result.executionTime).toBe('number')
+      
+      // serviceWorker can be null if not supported or failed
+      if (result.serviceWorker) {
+        expect(typeof result.serviceWorker.timeZone).toBe('string')
+        expect(typeof result.serviceWorker.language).toBe('string')
+        expect(typeof result.serviceWorker.userAgent).toBe('string')
+        expect(typeof result.serviceWorker.engine).toBe('string')
+      }
+    })
+
+    it('should have reasonable execution time', async () => {
+      const result = await getFpWorkerValidation()
+      expect(result.executionTime).toBeGreaterThanOrEqual(0)
+      expect(result.executionTime).toBeLessThan(10000) // Less than 10 seconds
+    })
+  })
+})
diff --git a/src/sources/fpworker_validation.ts b/src/sources/fpworker_validation.ts
new file mode 100644
index 0000000..1dd90bc
--- /dev/null
+++ b/src/sources/fpworker_validation.ts
@@ -0,0 +1,246 @@
+import { BotdError, State } from '../types'
+
+export interface FpWorkerValidationPayload {
+  windowScope: {
+    timeZone: string
+    language: string
+    userAgent: string
+    engine: string
+  }
+  serviceWorker: {
+    timeZone: string
+    language: string
+    userAgent: string
+    engine: string
+  } | null
+  isServiceWorkerSupported: boolean
+  isSharedWorkerSupported: boolean
+  executionTime: number
+}
+
+/**
+ * Gets the browser engine based on mathematical computation
+ * This uses floating point precision differences between browser engines
+ */
+function getEngine(): string {
+  const mathPI = 3.141592653589793
+  const result = mathPI ** -100
+  const resultStr = result.toString()
+  
+  // Different browser engines have slightly different floating point precision
+  const hashMap: Record<string, string> = {
+    '1.9275814160560204e-50': 'Blink',     // Chrome/Chromium (older versions)
+    '1.9275814160560185e-50': 'Gecko',     // Firefox
+    '1.9275814160560206e-50': 'WebKit',    // Safari / Chrome newer versions
+  }
+  
+  const detected = hashMap[resultStr]
+  
+  // For Chrome/Chromium browsers, we might get WebKit result due to precision changes
+  // Use additional checks to distinguish between Safari WebKit and Chrome Blink
+  if (detected === 'WebKit' && typeof window !== 'undefined') {
+    // Check for Chrome-specific features to distinguish from Safari
+    const isChrome = 'chrome' in window || navigator.userAgent.includes('Chrome')
+    if (isChrome) {
+      return 'Blink'
+    }
+  }
+  
+  return detected || 'unknown'
+}
+
+/**
+ * Gets fingerprint data for a given scope
+ */
+function getFingerprint() {
+  const ask = <T>(fn: () => T): T | undefined => {
+    try {
+      return fn()
+    } catch (e) {
+      return undefined
+    }
+  }
+
+  return {
+    timeZone: ask(() => Intl.DateTimeFormat().resolvedOptions().timeZone) || '',
+    language: navigator.language || '',
+    userAgent: navigator.userAgent || '',
+    engine: getEngine(),
+  }
+}
+
+/**
+ * Gets service worker fingerprint data
+ */
+function getServiceWorker(): Promise<FpWorkerValidationPayload['serviceWorker']> {
+  return new Promise((resolve) => {
+    // Check for service worker support
+    if (!('serviceWorker' in navigator)) {
+      resolve(null)
+      return
+    }
+
+    // Check if we're in a secure context (required for service workers)
+    if (!window.isSecureContext) {
+      resolve(null)
+      return
+    }
+
+    let resolved = false
+    const timeoutId = setTimeout(() => {
+      if (!resolved) {
+        resolved = true
+        resolve(null)
+      }
+    }, 2000)
+
+    const tryRegisterServiceWorker = async () => {
+      // Try multiple possible service worker paths
+      const possiblePaths = [
+        './fpworker-sw.js',          // Webpack copied file (playground)
+        '/fpworker-sw.js',           // Root level (production)
+        '/dist/fpworker-sw.js',      // Dist folder
+        './dist/fpworker-sw.js',     // Relative dist folder
+        '../dist/fpworker-sw.js',    // Parent dist folder
+        '/src/fpworker-sw.js',       // In src directory
+        './src/fpworker-sw.js'       // Relative src directory
+      ]
+      
+      for (const serviceWorkerPath of possiblePaths) {
+        if (resolved) break
+        
+        try {
+          const scope = `/botd-sw-${Date.now()}-${Math.random().toString(36).substr(2, 5)}/`
+          
+          const registration = await navigator.serviceWorker.register(serviceWorkerPath, { scope })
+          
+          const cleanup = () => {
+            registration.unregister().catch(() => {})
+          }
+
+          const tryGetData = (worker: ServiceWorker) => {
+            if (resolved) return
+
+            const channel = new MessageChannel()
+            
+            channel.port1.onmessage = (event) => {
+              if (!resolved) {
+                resolved = true
+                clearTimeout(timeoutId)
+                cleanup()
+                resolve(event.data)
+              }
+            }
+
+            try {
+              worker.postMessage('getFingerprint', [channel.port2])
+              
+              // Add a fallback timeout for this specific message
+              setTimeout(() => {
+                if (!resolved) {
+                  resolved = true
+                  clearTimeout(timeoutId)
+                  cleanup()
+                  resolve(null)
+                }
+              }, 1000)
+            } catch (e) {
+              if (!resolved) {
+                resolved = true
+                clearTimeout(timeoutId)
+                cleanup()
+                resolve(null)
+              }
+            }
+          }
+
+          // Wait for the service worker to be installed and activated
+          const waitForWorker = () => {
+            return new Promise<ServiceWorker | null>((workerResolve) => {
+              if (registration.active) {
+                workerResolve(registration.active)
+                return
+              }
+              
+              if (registration.installing) {
+                registration.installing.addEventListener('statechange', function onStateChange() {
+                  if (this.state === 'activated') {
+                    this.removeEventListener('statechange', onStateChange)
+                    workerResolve(registration.active)
+                  } else if (this.state === 'redundant') {
+                    this.removeEventListener('statechange', onStateChange)
+                    workerResolve(null)
+                  }
+                })
+              } else {
+                workerResolve(null)
+              }
+            })
+          }
+          
+          const worker = await waitForWorker()
+          
+          if (worker) {
+            tryGetData(worker)
+          } else {
+            if (!resolved) {
+              resolved = true
+              clearTimeout(timeoutId)
+              cleanup()
+              resolve(null)
+            }
+          }
+          
+          return // Exit the function if registration was successful
+          
+        } catch (pathError) {
+          // Try next path
+          continue
+        }
+      }
+      
+      // If no path worked, resolve with null
+      if (!resolved) {
+        resolved = true
+        clearTimeout(timeoutId)
+        resolve(null)
+      }
+    }
+
+    tryRegisterServiceWorker().catch(() => {
+      if (!resolved) {
+        resolved = true
+        clearTimeout(timeoutId)
+        resolve(null)
+      }
+    })
+  })
+}
+
+export default async function getFpWorkerValidation(): Promise<FpWorkerValidationPayload> {
+  try {
+    const start = performance.now()
+    
+    // Check for service worker and shared worker support
+    const isServiceWorkerSupported = 'serviceWorker' in navigator
+    const isSharedWorkerSupported = 'SharedWorker' in window
+
+    // Get fingerprints from both scopes
+    const [windowScope, serviceWorker] = await Promise.all([
+      Promise.resolve(getFingerprint()),
+      getServiceWorker(),
+    ])
+
+    const executionTime = performance.now() - start
+
+    return {
+      windowScope,
+      serviceWorker,
+      isServiceWorkerSupported,
+      isSharedWorkerSupported,
+      executionTime,
+    }
+  } catch (error) {
+    throw new BotdError(State.UnexpectedBehaviour, `Error in fpworker validation: ${error}`)
+  }
+}
-- 
2.50.1

